/************************************************************************************************
 * This code was automatically generated by Digital Twin Code Generator tool 0.3.9.
 * Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 *
 * Generated Date: Monday, August 5, 2019
 ***********************************************************************************************/

#include "system_interface.h"

#define MAX_MASSAGE_SIZE 256

//
//  Callback function declarations and DigitalTwin command names for this interface.
//

static void SystemInterface_Command_RebootCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext);

//
// Application state associated with this interface. In particular it contains 
// the DIGITALTWIN_INTERFACE_CLIENT_HANDLE used for responses in callbacks along with properties set
// and representations of the properrty update and command callbacks invoked on given interface
//
typedef struct SYSTEM_INTERFACE_STATE_TAG
{
    DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceClientHandle;

    char* rebootRequestId;
    SYSTEM_REBOOT_STATUS rebootStatus;

} SYSTEM_INTERFACE_STATE;

static SYSTEM_INTERFACE_STATE appState;

static const char System_RebootActiveResponse[] = "{ \"result\": \"reboot async command initiated and in progress\" }";
static const char System_RebootFailureResponse[] = "{ \"result\": \"reboot failed to process due to internal error\" }";
static const char System_RebootInProgressResponse[] = "{ \"result\": \"reboot already in progress\" }";
static const char System_RebootRunningState[] = "\"'reboot' command active\"";
static const char System_RebootSuccessState[] = "\"Process 'reboot' async command successfully\"";
static const char System_RebootErrorState[] = "\"Process 'reboot' failed\"";

DIGITALTWIN_CLIENT_RESULT SystemInterface_Reboot_UpdateStatus(SYSTEM_REBOOT_STATUS commandStatus,int statusCode)
{
    DIGITALTWIN_CLIENT_RESULT digitalTwinClientResult = DIGITALTWIN_CLIENT_OK;;

    if (commandStatus == SYSTEM_REBOOT_RUNNING)
    {
        DIGITALTWIN_CLIENT_ASYNC_COMMAND_UPDATE updateInProgress;
        DigitalTwinClientHelper_SetUpdateAsyncStatus(&updateInProgress, SystemInterface_RebootCommand, appState.rebootRequestId, System_RebootRunningState, DIGITALTWIN_ASYNC_STATUS_CODE_PENDING);

        LogInfo("SYSTEM_INTERFACE: reboot command is running.  Updating server process and invoke 'reboot' async command");
        digitalTwinClientResult = DigitalTwin_InterfaceClient_UpdateAsyncCommandStatusAsync(appState.interfaceClientHandle, &updateInProgress);
        if (digitalTwinClientResult != DIGITALTWIN_CLIENT_OK)
        {
            LogError("DigitalTwin_InterfaceClient_UpdateAsyncCommandStatus failed, error=%s.  Continuing execution of thread in any event", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinClientResult));
        }
    }
    else if (commandStatus == SYSTEM_REBOOT_COMPLETED)
    {
        // Set response as a JSON null when there's no response schema defined in this command
        char* serializedResponse = "null";

        DIGITALTWIN_CLIENT_ASYNC_COMMAND_UPDATE updateComplete;
        DigitalTwinClientHelper_SetUpdateAsyncStatus(&updateComplete, SystemInterface_RebootCommand, appState.rebootRequestId, serializedResponse, statusCode);

        digitalTwinClientResult = DigitalTwin_InterfaceClient_UpdateAsyncCommandStatusAsync(appState.interfaceClientHandle, &updateComplete);
        if (digitalTwinClientResult != DIGITALTWIN_CLIENT_OK)
        {
            LogError("DigitalTwin_InterfaceClient_UpdateAsyncCommandStatus failed, error=%s.", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinClientResult));
        }

        // Reset reboot status to inactive
        free(appState.rebootRequestId);
        appState.rebootRequestId = NULL;
        appState.rebootStatus = SYSTEM_REBOOT_INACTIVE;
    }
    else if (commandStatus == SYSTEM_REBOOT_ERROR)
    {
        DIGITALTWIN_CLIENT_ASYNC_COMMAND_UPDATE updateError;
        DigitalTwinClientHelper_SetUpdateAsyncStatus(&updateError, SystemInterface_RebootCommand, appState.rebootRequestId, System_RebootErrorState, 500);

        digitalTwinClientResult = DigitalTwin_InterfaceClient_UpdateAsyncCommandStatusAsync(appState.interfaceClientHandle, &updateError);
        if (digitalTwinClientResult != DIGITALTWIN_CLIENT_OK)
        {
            LogError("DigitalTwin_InterfaceClient_UpdateAsyncCommandStatus failed, error=%s.", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, digitalTwinClientResult));
        }

        // Reset reboot status to inactive
        free(appState.rebootRequestId);
        appState.rebootRequestId = NULL;
        appState.rebootStatus = SYSTEM_REBOOT_INACTIVE;
    }

    return digitalTwinClientResult;
}

static void SystemInterface_Command_RebootCallback(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* commandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* commandResponse, void* userInterfaceContext)
{
    SYSTEM_INTERFACE_STATE* interfaceState = (SYSTEM_INTERFACE_STATE*)userInterfaceContext;

    LogInfo("SYSTEM_INTERFACE: reboot command invoked.");
    LogInfo("SYSTEM_INTERFACE: reboot request payload=<%.*s>, context=<%p>", (int)commandRequest->requestDataLen, commandRequest->requestData, interfaceState);

    if (interfaceState->rebootStatus != SYSTEM_REBOOT_INACTIVE)
    {
        // If a async command is already in progress, do not allow simultaneous requests.
        // Note that the requirement for only one simultaneous asynchronous command at a time *is for simplifying the generated sample code only*.
        // The underlying DigitalTwin protocol will allow multiple simultaneous requests to be sent to the client; whether the
        // device allows this or not is a decision for the interface & device implementors.
        LogError("SYSTEM_INTERFACE: reboot async command already in progress");
        DigitalTwinClientHelper_SetCommandResponse(commandResponse, System_RebootInProgressResponse/*already-in-progress*/, 500);
    }
    else
    {
        // At this point we need to save the requestId.  This is what the server uses to correlate subsequent responses from this operation.
        if (mallocAndStrcpy_s(&interfaceState->rebootRequestId, commandRequest->requestId) != 0)
        {
            LogError("SYSTEM_INTERFACE: Cannot allocate requestId.");
            (void)DigitalTwinClientHelper_SetCommandResponse(commandResponse, System_RebootFailureResponse/*failure*/, 500);
            return;
        }

        if (DigitalTwinClientHelper_SetCommandResponse(commandResponse, System_RebootActiveResponse/*initiated-and-inprogress*/, DIGITALTWIN_ASYNC_STATUS_CODE_PENDING) != 0)
        {
            LogError("MXCHIP_INTERFACE: Failed setting response to server.");
            free(appState.rebootRequestId);
        }
        else
        {
            // Mark async command is running
            interfaceState->rebootStatus = SYSTEM_REBOOT_RUNNING;

            // Invoke device command here
            System_Command_Reboot();
        }

    }
}

// DigitalTwinSample_ProcessCommandUpdate receives commands from the server.  This implementation acts as a simple dispatcher
// to the functions to perform the actual processing.
void SystemInterface_ProcessCommandUpdate(const DIGITALTWIN_CLIENT_COMMAND_REQUEST* dtCommandRequest, DIGITALTWIN_CLIENT_COMMAND_RESPONSE* dtCommandResponse, void* userInterfaceContext)
{
    if (strcmp(dtCommandRequest->commandName, SystemInterface_RebootCommand) == 0)
    {
        SystemInterface_Command_RebootCallback(dtCommandRequest, dtCommandResponse, userInterfaceContext);
        return;
    }

    // If the command is not implemented by this interface, by convention we return a 501 error to server.
    LogError("SYSTEM_INTERFACE: Command name <%s> is not associated with this interface", dtCommandRequest->commandName);
    (void)DigitalTwinClientHelper_SetCommandResponse(dtCommandResponse, "\"Requested command not implemented on this interface\"", 501);
}

// SystemInterface_InterfaceRegisteredCallback is invoked when this interface
// is successfully or unsuccessfully registered with the service, and also when the interface is deleted.
static void SystemInterface_InterfaceRegisteredCallback(DIGITALTWIN_CLIENT_RESULT dtInterfaceStatus, void* userInterfaceContext)
{
    LogInfo("SystemInterface_InterfaceRegisteredCallback with status=<%s>, userContext=<%p>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, dtInterfaceStatus), userInterfaceContext);
    if (dtInterfaceStatus == DIGITALTWIN_CLIENT_OK)
    {
        // Once the interface is registered, send our reported properties to the service.  
        // It *IS* safe to invoke most DigitalTwin API calls from a callback thread like this, though it 
        // is NOT safe to create/destroy/register interfaces now.
        LogInfo("SYSTEM_INTERFACE: Interface successfully registered.");
    }
    else if (dtInterfaceStatus == DIGITALTWIN_CLIENT_ERROR_INTERFACE_UNREGISTERING)
    {
        // Once an interface is marked as unregistered, it cannot be used for any DigitalTwin SDK calls.
        LogInfo("SYSTEM_INTERFACE: Interface received unregistering callback.");
    }
    else
    {
        LogError("SYSTEM_INTERFACE: Interface received failed, status=<%s>.", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, dtInterfaceStatus));
    }
}

//
// Create DigitalTwin interface cllient handle
//
DIGITALTWIN_INTERFACE_CLIENT_HANDLE SystemInterface_Create()
{
    DIGITALTWIN_INTERFACE_CLIENT_HANDLE interfaceHandle;
    DIGITALTWIN_CLIENT_RESULT result;

    memset(&appState, 0, sizeof(SYSTEM_INTERFACE_STATE));

    appState.rebootStatus = SYSTEM_REBOOT_INACTIVE;

    if ((result = DigitalTwin_InterfaceClient_Create(SystemInterfaceId,  SystemComponentName, SystemInterface_InterfaceRegisteredCallback, (void*)&appState, &interfaceHandle)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SYSTEM_INTERFACE: Unable to allocate interface client handle for interfaceId=<%s>, componentName=<%s>, error=<%s>", SystemInterfaceId, SystemComponentName, MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        interfaceHandle = NULL;
    }

    else if ((result = DigitalTwin_InterfaceClient_SetCommandsCallback(interfaceHandle, SystemInterface_ProcessCommandUpdate)) != DIGITALTWIN_CLIENT_OK)
    {
        LogError("SYSTEM_INTERFACE: DigitalTwin_InterfaceClient_SetCommandsCallbacks failed. error=<%s>", MU_ENUM_TO_STRING(DIGITALTWIN_CLIENT_RESULT, result));
        SystemInterface_Close(interfaceHandle);
        interfaceHandle = NULL;
    }

    else
    {
        LogInfo("SYSTEM_INTERFACE: Created DIGITALTWIN_INTERFACE_CLIENT_HANDLE successfully for interfaceId=<%s>, componentName=<%s>, handle=<%p>", SystemInterfaceId, SystemComponentName, interfaceHandle);
        appState.interfaceClientHandle = interfaceHandle;
    }

    return interfaceHandle;
}

void SystemInterface_Close(DIGITALTWIN_INTERFACE_CLIENT_HANDLE digitalTwinInterfaceClientHandle)
{
    // On shutdown, in general the first call made should be to DigitalTwin_InterfaceClient_Destroy.
    // This will block if there are any active callbacks in this interface, and then
    // mark the underlying handle such that no future callbacks shall come to it.
    DigitalTwin_InterfaceClient_Destroy(digitalTwinInterfaceClientHandle);

    // After DigitalTwin_InterfaceClient_Destroy returns, it is safe to assume
    // no more callbacks shall arrive for this interface and it is OK to free
    // resources callbacks otherwise may have needed.

}
